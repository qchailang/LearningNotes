举例说明一下：

有A，B,C三个方法，但是在调用每一个方法之前，要求打印一个日志：某一个方法被开始调用了！

在调用每个方法之后，也要求打印日志：某个方法被调用完了！

一般人会在每一个方法的开始和结尾部分都会添加一句日志打印吧，这样做如果方法多了，就会有很多重复的代码，显得很麻烦，这时候有人会想到，为什么不把打印日志这个功能封装一下，然后让它能在指定的地方（比如执行方法前，或者执行方法后）自动的去调用呢？如果可以的话，业务功能代码中就不会掺杂这一下其他的代码，所以AOP就是做了这一类的工作，比如，日志输出，事务控制，异常的处理等。

AOP的一些术语
==============

#. 通知/增强（Advice）
   
   所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。【增强的逻辑】

   也就是上面说的 安全，事物，日志等。
#. 连接点（JoinPoint）
   
   所谓连接点是指那些被拦截到的点。在spring中,这些点指的是【需要被代理的方法】,因为spring只支持方法类型的连接点。

   连接点是spring允许你使用通知的地方，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点。
#. 切点（Pointcut）
   
   所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。【被代理方法中被增强的方法】

   在上面说的连接点的基础上来定义切点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。
#. 切面（Aspect）
   
   是切点【被增强的方法】和通知【增强的逻辑方法】（引介）的结合。

   连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。
#. 引入（introduction）

   引介是一种特殊的通知,在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。

   允许我们向现有的类添加新方法属性。就是把切面（也就是新方法属性：通知定义的）用到目标类中。
#. 目标（target）
   
   代理的目标对向，也就是被代理的对象

   织入中所提到的目标对象，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。
#. 代理(proxy)
   
   一个类被AOP织入增强后，就产生一个结果代理类。就是产生的代理对象

   整套aop机制都是通过代理实现。
#. 织入(weaving)
   
   把切面应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。

   这个过程有3种方式，spring采用的是运行时。
关键：切点定义了哪些连接点会得到通知。

**在 Spring AOP 中，所有的可执行方法都是 Join point，所有的 Join point 都可以植入 Advice；而 pointcut 可以看作是一种描述信息，它修饰的是 Join point，用来确认在哪些 Join point 上执行 Advice**

其他的一些内容
=============
AOP中的Joinpoint可以有多种类型：构造方法调用，字段的设置和获取，方法的调用，方法的执行，异常的处理执行，类的初始化。也就是说在AOP的概念中我们可以在上面的这些Joinpoint上织入我们自定义的Advice，但是在Spring中却没有实现上面所有的joinpoint，确切的说，Spring只支持方法执行类型的Joinpoint。

Advice注解一共有五种，分别是：
-----------------------------
#. @Before前置通知
   
   通知在切入点运行前执行，不会影响切入点的逻辑，虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)
#. @After后置通知
   
   通知在切入点正常运行结束后执行，在一个 join point 正常返回后执行的 advice，如果切入点抛出异常，则在抛出异常前执行。
#. @AfterThrowing异常通知
   
   通知在切入点抛出异常前执行，如果切入点正常运行（未抛出异常），则不执行。
#. @AfterReturning返回通知
   
   通知在切入点正常运行结束后执行，如果切入点抛出异常，则不执行
#. @Around环绕通知
   
   通知是功能最强大的通知，可以在切入点执行前后自定义一些操作。环绕通知需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。

在Spring中，通过动态代理和动态字节码技术实现了AOP

使用表达式配置切入点

exection(访问修饰符 类全路径.方法名(参数)

#. exection(* com.kulvv.add(..))
#. exection(* com.kulvv.*(..))
#. exection(* *.*(..))
#. exection(* save*(..)) //匹配以save开头的方法

@Aspect

在增强类中配制，配制切面。

@Before("execution(* com.kulvv.aop.User.add(..))")

在增强类中配制，配制增强

@Pointcut

在被增强的类中配制，配制切点，如果省略id属性，切点的名称就是方法名第一个字母小写


在 Spring AOP 中，使用 @Aspect 注解标识一个类是一个切面，然后在切面中定义切点（pointcut）和 增强（advice）：